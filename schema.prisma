generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String    @id @unique @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String    @unique
  refresh_token     String?
  access_token      String?   @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  riotIGN           String?
  mmr               Int?      @unique
  MMR               MMR?      @relation("MMR", fields: [mmr], references: [id], onDelete: Cascade)
  User              User      @relation("Accounts", fields: [userId], references: [id], onDelete: Cascade)
  ModLogs           ModLogs[] @relation("ModLogs")
  UserAccount       User?     @relation("PrimaryRiotAccount")

  @@index([userId], map: "Account_userId_fkey")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  User         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "Session_userId_fkey")
}

model User {
  id                   String        @id @unique @default(cuid())
  name                 String?
  team                 Int?
  primaryRiotAccountID String?       @unique
  email                String?       @unique
  emailVerified        DateTime?
  image                String?
  roles                String        @default("0x0")
  flags                String        @default("0x0")
  createdAt            DateTime      @default(now())
  Accolades            Accolades[]
  Accounts             Account[]     @relation("Accounts")
  Draft                Draft[]       @relation("PlayerDraftPick")
  AGM1                 Franchise?    @relation("AGM1")
  AGM2                 Franchise?    @relation("AGM2")
  AGM3                 Franchise?    @relation("AGM3")
  GM                   Franchise?    @relation("GM")
  ModLogs              ModLogs[]     @relation("ModHistory")
  PlayerStats          PlayerStats[] @relation("UserPlayerStats")
  Records              Records[]
  sessions             Session[]
  Status               Status?       @relation("PlayerStatus")
  Substitute           Substitute[]  @relation("Sub")
  SubbedOut            Substitute[]  @relation("Subbed")
  Captain              Teams?        @relation("Captain")
  PrimaryRiotAccount   Account?      @relation("PrimaryRiotAccount", fields: [primaryRiotAccountID], references: [providerAccountId])
  Team                 Teams?        @relation(fields: [team], references: [id])

  @@index([team], map: "User_team_fkey")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
}

model Accolades {
  id        Int     @id @unique @default(autoincrement())
  userID    String?
  season    Int
  tier      Tier
  accolade  String
  shorthand String
  Player    User?   @relation(fields: [userID], references: [id])

  @@index([userID], map: "Accolades_userID_fkey")
}

model Records {
  id     Int     @id @unique @default(autoincrement())
  userID String?
  season Int
  tier   Tier
  record String
  Player User?   @relation(fields: [userID], references: [id])

  @@index([userID], map: "Records_userID_fkey")
}

model Teams {
  id                 Int           @id @unique @default(autoincrement())
  name               String
  tier               Tier
  active             Boolean       @default(true)
  franchise          Int
  captain            String?       @unique
  midSeasonPlacement Int?
  GamesWon           Games[]       @relation("GamesWon")
  MapBans            MapBans[]
  AwayMatches        Matches[]     @relation("AwayMatches")
  HomeMatches        Matches[]     @relation("HomeMatches")
  PlayerStats        PlayerStats[]
  Substitutes        Substitute[]
  Captain            User?         @relation("Captain", fields: [captain], references: [id])
  Franchise          Franchise     @relation(fields: [franchise], references: [id])
  Roster             User[]

  @@index([franchise], map: "Teams_franchise_fkey")
}

model Franchise {
  id                    Int             @id @unique @default(autoincrement())
  name                  String
  slug                  String
  active                Boolean         @default(true)
  roleID                String?
  gmID                  String?         @unique
  agm1ID                String?         @unique
  agm2ID                String?         @unique
  agm3ID                String?         @unique
  transactionsChannelID String?
  DraftPicks            Draft[]
  AGM1                  User?           @relation("AGM1", fields: [agm1ID], references: [id], map: "Franchise_AGM1")
  AGM2                  User?           @relation("AGM2", fields: [agm2ID], references: [id], map: "Franchise_AGM2")
  AGM3                  User?           @relation("AGM3", fields: [agm3ID], references: [id], map: "Franchise_AGM3")
  GM                    User?           @relation("GM", fields: [gmID], references: [id], map: "Franchise_GM")
  Brand                 FranchiseBrand?
  Teams                 Teams[]
}

model FranchiseBrand {
  id               Int        @id @unique @default(autoincrement())
  franchise        Int?       @unique
  logo             String?
  colorPrimary     String?
  colorSecondary   String?
  description      String?    @db.Text
  urlDiscord       String?
  urlTwitter       String?
  urlMiscellaneous String?
  discordEmote     String?
  banner           String?
  draftMessage     String?    @db.Text
  Franchise        Franchise? @relation(fields: [franchise], references: [id])
}

model MMR {
  id            Int       @id @unique @default(autoincrement())
  numRanked     Int?
  numCombines   Int?
  numLastSeason Int?
  mmrCombines   Float?
  mmrRanked     Float?
  mmrBase       Float?
  mmrEffective  Float?
  mmrSeason     Float?
  lastPulled    DateTime?
  Account       Account?  @relation("MMR")
}

model Substitute {
  id       Int          @id @unique @default(autoincrement())
  team     Int?
  tier     Tier
  matchID  Int?
  subID    String? // this is the userID of the player who is SUBBING FOR the team
  subbedID String? // this is the userID of the player who is ON THE TEAM needing a sub
  Stats    PlayerStats?
  Match    Matches?     @relation(fields: [matchID], references: [matchID])
  Sub      User?        @relation("Sub", fields: [subID], references: [id])
  Subbed   User?        @relation("Subbed", fields: [subbedID], references: [id])
  Team     Teams?       @relation(fields: [team], references: [id])

  @@index([matchID], map: "Substitute_matchID_fkey")
  @@index([subID], map: "Substitute_subID_fkey")
  @@index([subbedID], map: "Substitute_subbedID_fkey")
  @@index([team], map: "Substitute_team_fkey")
}

model Matches {
  matchID       Int          @id @unique @default(autoincrement())
  tier          Tier
  matchType     MatchType
  dateScheduled DateTime
  home          Int?
  away          Int?
  matchDay      Int?
  season        Int          @default(8)
  group         Int?
  Games         Games[]
  MapBans       MapBans[]
  Away          Teams?       @relation("AwayMatches", fields: [away], references: [id], map: "Away_Team")
  Home          Teams?       @relation("HomeMatches", fields: [home], references: [id], map: "Home_Team")
  Substitutes   Substitute[]

  @@index([away], map: "Away_Team")
  @@index([home], map: "Home_Team")
}

model MapBans {
  id      Int          @id @unique @default(autoincrement())
  matchID Int
  order   Int // order denotes the selection. Index at 0
  type    MapBanType
  team    Int?
  map     String?
  side    MapBansSide?
  Match   Matches      @relation(fields: [matchID], references: [matchID])
  Team    Teams?       @relation(fields: [team], references: [id])

  @@index([matchID], map: "MapBans_matchID_fkey")
  @@index([team], map: "MapBans_team_fkey")
}

model Games {
  gameID        String        @id @unique
  // Forfeits will submit a datetime as the unique ID, and fill in the gameType as FORFEIT
  // Invalid matches include matches that do NOT have ONLY VDC players in the database or out of tier matches
  matchID       Int?
  season        Int           @default(8)
  tier          Tier
  gameType      GameType
  datePlayed    DateTime
  winner        Int?
  rounds        Int
  roundsWonHome Int
  roundsWonAway Int
  map           String?
  Match         Matches?      @relation(fields: [matchID], references: [matchID])
  WinningTeam   Teams?        @relation("GamesWon", fields: [winner], references: [id])
  PlayerStats   PlayerStats[] @relation("GamePlayerStats")

  @@index([matchID], map: "Games_matchID_fkey")
  @@index([winner], map: "Games_winner_fkey")
}

model PlayerStats {
  id            Int         @id @unique @default(autoincrement())
  userID        String
  gameID        String
  team          Int?
  agent         String
  // Use enums - ex. Agent.Chamber
  ratingAttack  Float?
  ratingDefense Float?
  acs           Int?
  hsPercent     Float?
  kills         Int?
  deaths        Int?
  assists       Int?
  firstKills    Int?
  firstDeaths   Int?
  plants        Int?
  defuses       Int?
  tradeKills    Int?
  tradeDeaths   Int?
  ecoKills      Int?
  ecoDeaths     Int?
  antiEcoKills  Int?
  exitKills     Int?
  clutches      Int?
  substituteID  Int?        @unique
  antiEcoDeaths Int?
  damage        Int?
  kast          Int?
  Game          Games       @relation("GamePlayerStats", fields: [gameID], references: [gameID], onDelete: Cascade, map: "GamePlayerStats")
  Substitute    Substitute? @relation(fields: [substituteID], references: [id])
  Team          Teams?      @relation(fields: [team], references: [id])
  Player        User        @relation("UserPlayerStats", fields: [userID], references: [id])

  @@index([gameID], map: "GamePlayerStats")
  @@index([team], map: "PlayerStats_team_fkey")
  @@index([userID], map: "PlayerStats_userID_fkey")
}

model Status {
  userID            String          @id @unique
  leagueStatus      LeagueStatus    @default(UNREGISTERED)
  contractStatus    ContractStatus?
  contractRemaining Int?
  Player            User            @relation("PlayerStatus", fields: [userID], references: [id], onDelete: Cascade)
}

model Draft {
  id        Int        @id @unique @default(autoincrement())
  season    Int
  tier      Tier
  round     Int
  pick      Int
  keeper    Boolean    @default(false)
  userID    String?
  franchise Int?
  Franchise Franchise? @relation(fields: [franchise], references: [id])
  Player    User?      @relation("PlayerDraftPick", fields: [userID], references: [id])

  @@index([franchise], map: "Draft_franchise_fkey")
  @@index([userID], map: "Draft_userID_fkey")
}

model ModLogs {
  id        Int        @id @unique @default(autoincrement())
  discordID String // this is the userID of the player who is being logged (Discord ID)
  modID     String // this is the userID of the mod who is logging (VDC ID)
  season    Int        @default(8)
  date      DateTime   @default(now())
  type      ModLogType
  message   String     @db.Text
  expires   DateTime?
  Player    Account    @relation("ModLogs", fields: [discordID], references: [providerAccountId])
  Moderator User       @relation("ModHistory", fields: [modID], references: [id])

  @@index([discordID], map: "ModLogs_discordID_fkey")
  @@index([modID], map: "ModLogs_modID_fkey")
}

model FAQ {
  id       Int     @id @unique @default(autoincrement())
  question String
  answer   String  @db.VarChar(999)
  visible  Boolean @default(true)
}

model ControlPanel {
  id    Int    @id @unique @default(autoincrement())
  name  String
  value String
  notes String
}

model ApiAccess {
  id               Int     @id @unique @default(autoincrement())
  key              String  @unique @default(uuid())
  owner            String? // Human readable key owner
  active           Boolean @default(true)
  rateLimit        Int     @default(30) // Default to 30 requests/min
  allowedEndpoints String  @db.LongText // List of allowed endpoints
}

enum Tier {
  PROSPECT
  APPRENTICE
  EXPERT
  MYTHIC
  MIXED
  // Used in non-tier bound combines
}

enum MatchType {
  PRE_SEASON
  BO2
  BO3
  BO5
}

enum GameType {
  COMBINE
  INVALID
  PRE_SEASON
  SEASON
  FORFEIT
  PLAYOFF
}

enum LeagueStatus {
  UNREGISTERED
  PENDING
  APPROVED
  DRAFT_ELIGIBLE
  FREE_AGENT
  RESTRICTED_FREE_AGENT
  SIGNED
  GENERAL_MANAGER
  RETIRED
  SUSPENDED
}

enum ContractStatus {
  SIGNED
  SUBBED_OUT
  INACTIVE_RESERVE
  ACTIVE_SUB
}

enum MapBanType {
  PICK
  BAN
  DISCARD
  DECIDER
}

enum ModLogType {
  NOTE
  INFORMAL_WARNING
  FORMAL_WARNING
  MUTE
  BAN
}

enum MapBansSide {
  ATTACK
  DEFENSE
}

//TODO: Adding this comment to test workflow.  This can be deleted.